"use strict";(self.webpackChunkmirzafahmi_github_io=self.webpackChunkmirzafahmi_github_io||[]).push([[2506],{4531:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/django_rq-a85b285893bba83af9b21a8eae215c8a.jpg"},8395:e=>{e.exports=JSON.parse('{"permalink":"/blog/accidentally-use-redis","source":"@site/blog/2025-11-27-redis/index.md","title":"How I accidentally use Redis (sort of)","description":"Redis. I bet every software developer has heard of or used Redis in their project at some point. Or learn about it at least for the technical interview. However, not many have had the chance to use or utilize it as I have. Up to this point, I just know that Redis is an in-memory key-value store that can be used to implement queues and pub/sub messaging. Let me re-catch what Redis is. Redis is an open-source, in-memory, NoSQL key-value store used as a database, cache, and message broker. It\'s  an all-around software that can be used to cache or even as a  database (please don\'t do this).","date":"2025-11-27T00:00:00.000Z","tags":[],"readingTime":3.42,"hasTruncateMarker":true,"authors":[{"name":"Ahmad Mirza Fahmi","title":"Backend Software Engineer","socials":{"linkedin":"https://www.linkedin.com/in/mirzafahmi/","github":"https://github.com/mirzafahmi"},"imageURL":"https://github.com/mirzafahmi.png","key":"amf","page":null}],"frontMatter":{"slug":"accidentally-use-redis","title":"How I accidentally use Redis (sort of)","authors":["amf"],"tags":[]},"unlisted":false,"nextItem":{"title":"What made me start programming?","permalink":"/blog/what-made-me-start-programming"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(6540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},9305:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var s=n(8395),a=n(4848),i=n(8453);const o={slug:"accidentally-use-redis",title:"How I accidentally use Redis (sort of)",authors:["amf"],tags:[]},r=void 0,d={authorsImageUrls:[void 0]},l=[{value:"Redis help increase my API performance",id:"redis-help-increase-my-api-performance",level:2},{value:"It is easy to setup and run",id:"it-is-easy-to-setup-and-run",level:2},{value:"Wrapping Up",id:"wrapping-up",level:2}];function c(e){const t={code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Redis. I bet every software developer has heard of or used Redis in their project at some point. Or learn about it at least for the technical interview. However, not many have had the chance to use or utilize it as I have. Up to this point, I just know that Redis is an in-memory key-value store that can be used to implement queues and pub/sub messaging. Let me re-catch what Redis is. Redis is an open-source, in-memory, NoSQL key-value store used as a database, cache, and message broker. It's  an all-around software that can be used to cache or even as a  database (please don't do this)."}),"\n",(0,a.jsx)(t.h2,{id:"redis-help-increase-my-api-performance",children:"Redis help increase my API performance"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"0\u20131s \u2014 Instant Response:"})," Users expect immediate feedback or they assume the app is broken."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"1\u20133s \u2014 Acceptable Wait:"})," Users tolerate a short delay if a loader or animation is shown."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"3\u20137s \u2014 Attention Drift:"})," Users start losing focus and may shift attention elsewhere."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"7\u201315s \u2014 Drop-Off Zone:"})," Most users abandon the task unless it\u2019s very important."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"15s+ \u2014 Abandonment:"})," Users fully disengage and won\u2019t return to the action."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:'In my latest project, I encountered terrible performance on one of my API, which took almost 10 seconds to response due to media upload to the storage bucket. A brief stack about this project, it uses Python, Django, and Django Rest Framework as part of the backend which is mostly synchronous, so async support is limited without external tools. It is not acceptable for modern apps as it falls under "Drop-Off Zone" so I plan to handle the media upload in the background. Then I encountered one of the solution to use a queue like Redis. But Redis alone is not enough to handle background tasks reliably, that is why a worker like django_rq is required to execute the task.'}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"My Image",src:n(4531).A+"",width:"1052",height:"499"})}),"\n",(0,a.jsx)(t.p,{children:'I choose Redis due to its simplicity to set up and ease of integration with django using django_rq. It is also lightweight and suitable for my project due to server resource constraints. So I converted the  method related to the media upload into "task" using the django_rq packages. During the process, I also learn that uploading a big file can be broken into smaller chunks which makes the upload process more reliable so that if one of the chunks fails to upload, only that chunk will get retried instead whole file. It also reduces memory load, which is a big plus in my context due to limited server resource. Lastly, it also improve the user experience as it can give real-time progress feedback.'}),"\n",(0,a.jsx)(t.h2,{id:"it-is-easy-to-setup-and-run",children:"It is easy to setup and run"}),"\n",(0,a.jsx)(t.p,{children:"It can be deployed using docker-compose along with django server. This setup will be run with one worker."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'version: "3.8"\n\nservices:\n  redis:\n    image: redis:7-alpine\n    volumes:\n      - redis_data:/data\n    command: redis-server --bind 0.0.0.0 --requirepass testredis --protected-mode yes\n\n  web:\n    build: .\n    ports:\n      - "80:8000"\n    env_file:\n      - .env\n    environment:\n      - REDIS_URL=redis://:testredis@redis:6379/0\n    depends_on:\n      - redis\n    command: >\n      sh -c "python manage.py rqworker default & \n             python manage.py runserver 0.0.0.0:8000"\n\nvolumes:\n  redis_data:\n'})}),"\n",(0,a.jsx)(t.p,{children:"And you have this kind of API with method that handle something in background."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'def process_file_background(filename):\n    # simulate long processing\n    time.sleep(10)\n    print(f"Finished processing file: {filename}")\n    return f"{filename} processed!"\n\n@api_view(["POST"])\ndef upload_file(request):\n    filename = request.data.get("filename", "unknown.txt")\n\n    queue = django_rq.get_queue("default")\n    job = queue.enqueue(process_file_background, filename)\n\n    return Response({\n        "message": "File received. Processing in background...",\n        "job_id": job.id,\n    })\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The server response will immediately return with 200 status while handling the task in the background as ",(0,a.jsx)(t.code,{children:"queue.enqueue()"})," will handle called function in the background. Without this solution, my server will be blocked and take time to response for at least for 10 seconds."]}),"\n",(0,a.jsx)(t.h2,{id:"wrapping-up",children:"Wrapping Up"}),"\n",(0,a.jsx)(t.p,{children:"By combining Redis with django_rq, I was able to move slow, blocking operations into background workers without rewriting my entire stack to async. The performance improvement was immediate, the user experience became smoother, and the overall system became more reliable. It\u2019s not the only solution but for Django projects with limited resources, it is definitely one of the most practical ones."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);